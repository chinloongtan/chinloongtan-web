{"pageProps":{"posts":[{"slug":"pm2-commands-nodejs-backend","frontmatter":{"path":"/blog/pm2-commands-nodejs-backend","date":"2022-01-10T17:06:00.000Z","title":"PM2 commands for your node.js backend","excerpt":"Essentials for deployment","tags":["node.js"]},"content":"\n\nPM2 is a very handy tool to keep your node.js application online. Here's a list of commands that are essential for deployment.\n\n#### Commands\n\n1. `pm2 start --name=web yarn --start` or `pm2 start --name=web --interpreter=bash yarn -- start`\n\nStart your application using `yarn start` with `pm2` and assign a name `web` to the application.\n`--name` is useful for multiple applications in the same server. For example, backend server and web applications.\n\n`--interpreter=bash` if your terminal should run with bash.\n\n<br />\n\n2. `pm2 delete web` or `pm2 delete all`\n\nRemove the process that is running the `web` application, if you assign a name previously. Or otherwise, delete with process id is possible as well.\n\n<br />\n\n3. `pm2 list` or `pm2 status`\n\nShow list of running processes managed by `pm2`.\n\n<br />\n\n\n4. `pm2 logs` or `pm2 logs web`\n\nRetrieve logs of running processes.\n\n<br />\n\n5. `pm2 flush`\n\nRemove currently logged output in log files.\n\n<br />\n\n\n\n#### Config file\n\nIf you have multiple applications to manage, it is recommended to use pm2 config file to manage the config of each application.\n\nIn parent directory:\n\nRun `pm2 ecosystem`\n\nto create a config file, Ecosystem File.\n\nA `ecosystem.config.js` file will be generated.\n\nHere's a sample config file I used for my side project.\n\n```\nmodule.exports = {\n  apps: [\n    {\n      name: 'web',\n      script: 'yarn',\n      args: 'start',\n      cwd: './myproject-web',\n      interpreter: 'bash',\n      instances: 1,\n      env_production: {\n        NODE_ENV: 'production',\n        PORT: 3000,\n      },\n    },\n    {\n      name: 'api',\n      script: 'yarn',\n      args: 'start',\n      cwd: './myproject-backend',\n      interpreter: 'bash',\n      instances: 1,\n      env_production: {\n        NODE_ENV: 'production',\n        PORT: 5000,\n      },\n    }\n  ],\n};\n```\n\nThat's all! Hope it helps.\n\nCheers.","fullPath":"/Users/chinloong/makespace/chinloongtan-web/src/content/blog/2022/01/10-pm2-commands/index.md","timeToRead":2},{"slug":"send-email-with-nodemailer-and-zoho-mail","frontmatter":{"path":"/blog/send-email-with-nodemailer-and-zoho-mail","date":"2022-02-13T17:45:00.000Z","title":"Send email with nodemailer and Zoho mail SMTP","excerpt":"An alternative to SendGrid","tags":["node.js"]},"content":"\nToday I learned that I can send email with Zoho mail SMTP in my node.js application. Previously I am using SendGrid and decided to browse for alternative, and figured that Zoho mail SMTP is as simple as sending email with SendGrid.\n\n<br />\n\n#### Let's send that email!\n\n1. Add `nodemailer` to your node application\n\n```\nyarn add nodemailer\n```\n\n2. Import and start sending email\n\n```\nconst nodemailer = require('nodemailer');\n\nconst transporter = nodemailer.createTransport({\n  host: \"smtp.zoho.com\",\n  secure: true,\n  port: 465,\n  auth: {\n    user: \"your@zoho.mail\",\n    pass: process.env.ZOHO_APP_PASSWORD,\n  },\n});\n```\n\n```\nconst msg = {\n  to: email,\n  from: 'sender@email.address', // Change to your verified sender\n  subject: 'Your receipt',\n  text: 'Thank you for purchasing with us.',\n  html: emailTemplate, // html string or ejs template\n}\n\ntransporter.sendMail(msg, function(error, info) {\n  // handler\n});\n```\n\nFor the password, it is recommended to use Zoho app password. It works with two-factor authentication enabled for your Zoho account, and is easier to manage in case it is compromised.\n\nThat's it!\n\nHope that helps.\n\nCheers.\n","fullPath":"/Users/chinloong/makespace/chinloongtan-web/src/content/blog/2022/02/13-nodejs-mailer/index.md","timeToRead":1},{"slug":"socket-programming","frontmatter":{"path":"/blog/socket-programming","date":"2023-11-08T09:30:00.000Z","title":"Socket programming","excerpt":"File transfer application","tags":["react-native","node.js"]},"content":"\nAbout 3 months ago, I am looking to build an app as a side project to explore different type of application that can be built with React Native.\n\nAfter a quick round of idea selection, I decided to build a [file transfer app](https://play.google.com/store/apps/details?id=app.mvphub.filelinkup). Part of the consideration being it scratches my own itch as I regularly transfer files between my Android and iOS devices.\n\n#### 1. Requirements\n\nApp should works\n\n- Offline\n- Send original file without compression / loss of quality\n\n#### 2. Journey\n\nInitial attempt was to use bluetooth to achieve that. Since wearables and devices connect and sync data from each other as I experienced it.\nPlus back in the days before cloud solutions, bluetooth file sharing was working okay.\n\nBluetooth technology quickly confuses me it's variation like bluetooth vs. bluetooth low energy (BLE), scanning and connecting devices are a big hurdle before getting into transmitting data between devices.\n\nThen, I am looking for feasible alternative and arrived at a WiFi network approach with TCP socket.\nI am familiar with the paradigm with my experiences working with chat and video streaming applications.\n\nA quick test of the setup with TCP server and client proofs that connecting devices are easier, and sending text data was achieved shortly after.\n\n---\n\nThe first challenge surfaced and it was me asking myself \"How to send image using text string?\".\n\nNot long after that, I added a image picker library into the app and using the `base64` encoding to get text string, which will be used to send over the connection.\n\nWhile sending the image with `base64` from one side to the other has no issue, another challenge quickly arise.\n\n\"How to know if the file content has finished sending?\" This is so that I can call the `save` function on the receiver, to save the file content.\n\nBrowsing through the internet, I understand that socket will continuously listening to data. It is up to me to either close the socket, and the last bit of data will be flushed out of the buffer and I can save the file when the event `onClose` is triggered.\n\nThat works if I am sending a single file, but what if I am sending multiple files (let's say 100) in one go?\n\nNow the alternative is to send a special string as a delimiter to indicate the termination of the file content.\n\nWith `base64` encoding, `@` is surely not part of the character that will exists, therefore it is a good candidate for this use case.\n\n---\n\n-_Part 2 end_-\n","fullPath":"/Users/chinloong/makespace/chinloongtan-web/src/content/blog/2023/11/08-socket-programming/index.md","timeToRead":2}],"totalCount":3,"tag":"node.js"},"__N_SSG":true}